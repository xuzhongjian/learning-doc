### 进程和线程 ###

进程是资源分配的基本单位。

线程是任务调度的基本单位。

一个进程中可以拥有多个线程，每个线程独立运行，共享进程的资源

区别：

1. 拥有资源：
   + 系统将资源分配到进程，进程拥有资源，线程不拥有资源。同一个进程中的线程只能共享进程中的资源。
2. 调度：
   + 线程是调度的基本单位，同一个进程中，线程的切换不会引起进程的切换，但是从一个进程中的线程切换到另一个线程中的进程，会引起进程的切换。
3. 系统开销：
   + 创建或撤销一个进程的时候，系统都会为其分配或回收内存、IO等资源。线程的创建和撤销的时候只需要设置少量的寄存器。在系统开销的角度，创建和撤销一个进程会比创建和撤销一个线程的开销大很多。
4. 通信
   + 进程间通信要是用IPC手段，但是线程间通信可以直接通过读取同一个进程的共享的资源。

### 死锁 ###

造成死锁的四个条件：

1. 持有和等待
2. 环路等待
3. 不可强占
4. 资源互斥

和造成死锁的四个条件相对应，解决死锁的方法：

1. 一次性申请所有资源
2.  给资源编号，没给线程只能按照顺序进行请求资源
3. 如果申请不到资源时，释放已有的资源
4. **无法破坏这个条件**

### 三次握手 ###

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png)

第三次握手的原因：

增加第三次握手的过程是为了，防止在第一次握手的过程因为网络问题，导致没有及时的被服务器收到。然后客户端再次向服务端发起连接请求，然后第一次超时的连接到达了服务端，然后会开启多个tcp连接。如果延迟到达的请求过多，会导致服务器开启段连接过多，导致服务器异常。

### 四次挥手 ###

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)
为什么要四次挥手？
因为tcp是双工的，数据的传输是双向的。四次挥手中的前两次挥手，是客户端将客户端向服务端传输数据的过程断开，后两次挥手是服务端断开服务端对客户端的数据传输。中间的过程是服务端对客户端数据的单向传输。

第四次挥手发出之后，客户端为什么要等待两个MSL？
如果第四次挥手没有按时抵达服务端，那么服务端会在第三次挥手发出的2MSL（也就是第四次挥手发出后的1MSL）后，重新发出第三次挥手。这次重新发出的挥手，会在失败的第四次挥手发出后的2MSL到达客户端。这也就是2MSL等待时间的由来，TIME_WAIT。


### 计算机网络 N 层结构 ###
五层：
	应用层
	传输层
	网络层
	数据链路层
	物理层

四层：
	应用层
	传输层
	网络层
	网络接口层

七层：
	应用层
	表示层
	会话层
	传输层
	网络层
	数据链路层
	物理层

### HTTP ###

#### 状态码 ####
200	OK
301 重定向
400 请求错误
401 未授权
403 请求被拒绝
404 不存在
405 这个HTTP请求方法不支持
500 服务器错误
502 网关错误
504 网关超时

#### HTTPS加密 ####
对称加密：
	使用同一个密钥来对来加密和解密。
	+ 运算速度快
	+ 没办法安全的将密钥发送给对方

非对称加密：
	使用不同的密钥加密。
	+ 可以公开的将密钥发送给对方
	+ 运算速度慢

HTTPS不是新协议，HTTPS是HTTP先和SSL通信，然后由SSL和TCP进行通信，SSL使用的是加密方式是由对称加密和非对称加密混合的加密：
1. 客户端向服务端发起请求，服务端将【公钥】返回给客户端。
2. 客户端获取到【公钥】之后，生成一个【会话密钥】，使用【公钥】将【会话密钥】加密。
3. 将加密后的【会话密钥】传送给服务端。
4. 服务端使用【私钥】解密，获取【会话密钥】。
5. 客户端和服务端通过【会话密钥】进行通信。

上面的【公钥】和【私钥】使用的是非对称加密，【会话密钥】使用的是对称加密。

### DNS协议 ###

1、在浏览器中输入 www.xuzhongjian.com 操作系统会检查 hosts 文件，如果存在这个域名的对应的ip地址，就首先使用这个 IP 地址。
2、如果没有，就会查找本地 DNS 服务器。如果本地 DNS 服务器内存在这个域名对应的 IP 地址，那么就返回。
3、如果没有，就会将请求转发到 13 个根服务器，然后由根域名服务器请求 .com 对应的 IP 地址，然后在由该服务器查找 xuzhongjian.com 对应的 IP 地址。
4、找到 xuzhongjian.com 的 IP 地址之后，向这个地址请求 www.xuzhongjian.com 的 IP 地址，这样完成了一次 DNS 解析的过程。

从本地查询到本地 DNS 服务器的查询是递归查询，从本地 DNS 服务器到根服务器、一级 DNS 服务器的查询是迭代查询。

### HTTP方法 ###

GET		获取资源
DELETE	删除资源
PUT 	（按照客户端）创建资源，幂等，或者更新资源
POST	（按照服务端）创建资源，或者更新资源

#### GET和POST的区别 ####

1. 按照 HTTP 协议的定义，GET 用来获取资源， POST 用来上传资源。
2. GET 的参数拼接在URL的后面， POST 的参数在实体主体中。
3. GET 方法是幂等的，但是 POST 不是。

### 多路复用 ###

Linux 的 IO 多路复用策略

#### select ####

1. 将需要监听的连接存储到数组中，分别将【可读】、【可写】、【异常情况】的事件分别存储到三个fd_set中。
2. 应用进程调用 select 的时候，将三个 fd_set 传入内核中。
3. 内核收到三个 fd_set 之后，对三个 fd_set 进行遍历，查看那些 fd 满足对应的事件。
4. 将满足事件的 fd 保留返回给对应的应用进程。
5. 应用进程再对对应的 fd 进行对应的操作。

select的缺点：
1. fd_set是一个数据结构，物理机器上的限制，长度只能是1024。所以最多只能同时监听 1024 个连接。
2. 从应用进程将 fd_set 拷贝到内核空间需要花费时间。
3. 在内核中需要对 fd_set 中的数据进行逐个遍历。


#### poll ####
poll 和 select 相似，区别在于poll在数据结构上，将 select 的数组变成了链表。这样可以支持更多的并发量，但是上面的2和3两个问题依旧没有解决。

#### epoll ####

epoll 相较于 select 和 poll来说，复杂一些。

内核事件表：一个红黑树的结构的树。树的节点是 fd 。
fd：一个 fd 表示一个连接的一个事件。

1. 创建内核事件表	epoll_create
	这里主要是向内核申请创建一个 fd ，这个描述符用来保存应用进程需要监控连接和这个连接对应的事件。
2. 添加或移出监控的fd和事件类型	epoll_ctl
	调用此方法可以是向内核的内核事件表中动态的添加和移出 fd 和对应事件类型。
3. 绑定回调事件	epoll_wait
	内核事件表的 fd 会绑定一个回调函数，当被监听的事件发生的时候，调用这个回调函数，将事件加入到一个等待队列中。
	epoll_wait 方法返回的时候内核会把活跃事件队列里的fd和事件类型返回给应用进程。
