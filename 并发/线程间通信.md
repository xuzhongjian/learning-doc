# 线程间通信 #

## volatile ##

关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。

volatile 的两个作用：

1. 保证内存可见性
   - 保证变量的修改，每次的写入都是直接写入到主内存中；每次对变量的读取都是从主内存中读取；
![jmm内存模型](../imgs/jmm.png)
2. 防止指令重排
   - 在volatile操作前后添加上内存屏障，禁止指令重排。

### volatile的内存屏障 ###

1. 在每个volatile写操作的前面插入一个StoreStore屏障。
2. 在每个volatile写操作的后面插入一个StoreLoad屏障。
3. 在每个volatile读操作的后面插入一个LoadLoad屏障。
4. 在每个volatile读操作的后面插入一个LoadStore屏障。

## synchronized ##

使用synchronized：

1. 修饰实例方法

    同一个实例，只能有一个线程执行这个方法。

    ```java
    package com.xuzhongjian.thread.model;

    /**
    * @author zjxu97 at 1/3/21 11:17 PM
    */
    public class SynchronizedTest {

        public synchronized void test() {
            // TODO
        }
        
    }
    ```

2. 修饰静态方法

    所有的这个类的实例化的对象中，只能有一个线程能执行这个方法。

    ```java
    package com.xuzhongjian.thread.model;

    /**
    * @author zjxu97 at 1/3/21 11:20 PM
    */
    public class SynchronizedTest {

        public static synchronized void test() {
            // TODO
        }

    }
    ```

3. 修饰对象
   1. 修饰this：修饰this，同一个实例，只能有一个线程执行这个方法。
   2. 修饰一个对象：这个用法和后面的notify，wait联合使用，可以实现基本的线程间通信。

任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。**表面上看，synchronized是加锁，但是实际上是对某个对象的监视器的竞争。**
