# 并发 

## Synchronized

### 问题一：Synchronized用过吗？其原理是什么？
synchronized是一个互斥同步锁，synchronized是基于每个对象的监视器来实现的（monitor）。基于底层的monitorenter和monitorexit来实现的。在加锁的代码开始处，插入monitorenter语句，如果没有线程获取了这个对象的监视器，那么当前这个线程取得这个线程的监视器。在加锁的代码的结尾处，插入monitorexit语句，表示释放这个对象的锁。

### 问题二：synchronized对象的锁 ，这个“锁”到底是什么？如何确定对象的锁？
锁就是监视器。

### 问题三：什么是可重入性 ， 为什么说Synchronized是可重入锁？
可重入性：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。

Synchronized配合对象的监视器使用一个计数器来实现可重入性。如果计数器的值为零，那么状态为没有线程持有这个对象的锁。

### 问题四：JVM对Java的原生锁做了哪些优化？
1. 偏向锁		大多数情况下，锁都是由同一个线程获得的。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
2. 轻量级锁	在偏向锁cas替换对象头中的mark word的时候，如果替换失败，那么表示这次锁的争夺失败。线程进入自旋状态。在同步代码块执行的速度快的场景下具有很高的效率。
3. 重量级锁	在轻量级锁尝试自旋获取锁时候失败，就是阻塞同步锁。

### 问题五：为什么说Synchronized是非公平锁？
非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。

### 问题六：什么是锁消除和锁粗化 ？
锁消除和锁粗化都是编译器级别对锁的优化。
锁消除：没有必要加锁的代码，但是确加了锁，在编译器编译的时候，会对加的锁删除，将锁消除。
锁粗化：锁粗化是跟锁消除的一个另一面：当需要加锁，但是锁加的粒度太细了。在编译器编译阶段，会将粒度太细没必要的锁，粗化成一个或多个大的锁。

### 问题七：为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？
不管是否会产生竞争，任何的数据操作都必须要先加锁、后操作。这样的策略就是悲观锁。synchronized的枷锁策略就是，在代码前后插入monitorenter、monitorexit。所以很明显，这是一个悲观锁。
乐观锁的核心算法是cas compare and swap。

### 问题八：乐观锁一定就是好的吗？

乐观锁，cas。存在三个问题：
1. ABA问题
2. 自旋开销过大
3. 只能针对单个变量进行cas

## 锁

https://blog.csdn.net/weixin_41566126/article/details/106563405

### 问题一： 跟 Synchronized相比 ，可重入锁ReentrantLock其实现原理有什么不同？
基于 AQS ，底层使用的是cas。Synchronized是基于对象的监视器。
### 问题二：那么请谈谈AQS框架是怎么回事儿？
AQS（AbstractQueuedSynchronizer类）是一个用来构建锁和同步器的框架，各种Lock包中的锁（常用的有ReentrantLock、ReadWriteLock），以及其他如Semaphore、CountDownLatch，甚至是早期的FutureTask等，都是基于AQS来构建：
1. AQS在内部定义了一个volatileintstate变量，表示同步状态：当线程调用lock方法时，如果state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将state=1；如果state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。
2. AQS通过Node内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。
	+ Node类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫waitStatus（有五种不同取值，分别表示是否被阻塞，是否等待唤醒，是否已经被取消等），每个Node结点关联其prev结点和next结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个FIFO的过程。
	+ Node类有两个常量，SHARED和EXCLUSIVE，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作（信号量Semaphore就是基于AQS的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如ReentranLock）。
3. AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。
4. AQS和Condition各自维护了不同的队列，在使用Lock和Condition的时候，其实就是两个队列的互相移动。

### 问题三：请尽可能详尽地对比下Synchronized 和 ReentrantLock的异同

1. 实现：synchronized是由jvm实现的，可重入锁是由jdk实现的。
2. 公平性：synchronized是非公平锁，ReentrantLock可以选择公平或者不公平。
3. 超时：synchronized没有办法设置超时时间，如果没有办法获得，那么会一直阻塞，re可以设置超时等待时间。
4. 显式释放：synch不需要显式释放锁，但是re需要显式释放锁

### 问题四： ReentrantLock 是如何实现可重入性的？

根据AQS中state状态的值。

### 问题五： 除了ReetrantLock，你还接触过JUC中的哪些并发工具？

略

### 问题六： 请谈谈ReadWriteLock 和 StampedLock。

略

### 问题七： 如何让Java的线程彼此同步？你了解过哪些同步器？请分别介绍下 。

 CyclicBarrier 和 CountDownLatch。

### 问题八： CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？

**CyclicBarrier：**字面意思是“可循环使用的屏障”。

它的作用是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。

```java
package com.zjxu9;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author zjxu97 at 2/24/21 11:29 PM
 */
public class CyclicBarrierTest {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();

        for (int i = 0; i < 7; i++) {
            executorService.submit(new Run());
        }
    }
}

class Run implements Runnable {
    private static final CyclicBarrier c = new CyclicBarrier(4, () -> System.out.println("barrierAction: 召唤神龙!"));

    @Override
    public void run() {
        Random random = new Random();
        int threadId = random.nextInt(100);
        try {
            System.out.println("thread run1 now, " + threadId);
            c.await();
            System.out.println("thread run2 now, " + threadId);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
//-------//-------//-------//-------//-------//-------//-------
thread run1 now, 70
thread run1 now, 97
thread run1 now, 72
thread run1 now, 24
thread run1 now, 61
thread run1 now, 94
thread run1 now, 95
barrierAction: 召唤神龙!
thread run2 now, 24
thread run2 now, 70
thread run2 now, 72
thread run2 now, 97
```





**CountDownLatch**：是一种多线程控制工具类，被称为到计数器，这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计数结束再开始执行。

```java
package com.zjxu9;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author zjxu97 at 2/24/21 11:48 PM
 */
public class CountDownLatchTest implements Runnable {
    private static final CountDownLatch end = new CountDownLatch(10);

    @Override
    public void run() {
        try {
            Thread.sleep(2000);
            System.out.println("模拟任务");
            //减少数值1
            end.countDown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    public static void main(String[] args) throws InterruptedException {
        ExecutorService exec = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            exec.submit(new CountDownLatchTest());
        }
        //数值减少为0时唤醒所有等待线程执行操作
        end.await();
        //执行任务
        System.out.println("执行任务");
        exec.shutdown();
    }
}
//-----------//-----------//-----------//-----------
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
模拟任务
执行任务
```



## 线程池 ##

### 问题一：Java中的线程池是如何实现的？ ###

### 问题二：创建线程池的几个核心构造参数？ ###

### 问题三：线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？ ###

### 问题四：既然提到可以通过配置不同参数创建出不同的线程池，那么Java中默认实现好的线程池又 有哪些呢？请比较它们的异同 。 ###

### 问题六：如何在Java线程池中提交线程？ ###





##  Java 内存模型相关问题 ##


### 问题一：什么是Java的内存模型，Java中各个线程是怎么彼此看到对方的变量的？
### 问题二：请谈谈volatile有什么特点，为什么它能保证变量对所有线程的可见性？
### 问题三：既然volatile能够保证线程间的变量可见性，是不是就意味着基于volatile变量的运算就是并 发安全的 ？
### 问题四：请对比下volatile对比Synchronized的异同
### 问题五：很多人都说要慎用ThreadLocal，谈谈你的理解，使用ThreadLocal需要注意些什么？