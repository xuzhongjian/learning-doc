# 并发 

## Synchronized

### 问题一：Synchronized用过吗？其原理是什么？
synchronized是一个互斥同步锁，synchronized是基于每个对象的监视器来实现的（monitor）。基于底层的monitorenter和monitorexit来实现的。在加锁的代码开始处，插入monitorenter语句，如果没有线程获取了这个对象的监视器，那么当前这个线程取得这个线程的监视器。在加锁的代码的结尾处，插入monitorexit语句，表示释放这个对象的锁。

### 问题二：synchronized对象的锁 ，这个“锁”到底是什么？如何确定对象的锁？
锁就是监视器。

### 问题三：什么是可重入性 ， 为什么说Synchronized是可重入锁？
可重入性：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。

Synchronized配合对象的监视器使用一个计数器来实现可重入性。如果计数器的值为零，那么状态为没有线程持有这个对象的锁。

### 问题四：JVM对Java的原生锁做了哪些优化？
1. 偏向锁		大多数情况下，锁都是由同一个线程获得的。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。
2. 轻量级锁	在偏向锁cas替换对象头中的mark word的时候，如果替换失败，那么表示这次锁的争夺失败。线程进入自旋状态。在同步代码块执行的速度快的场景下具有很高的效率。
3. 重量级锁	在轻量级锁尝试自旋获取锁时候失败，就是阻塞同步锁。

### 问题五：为什么说Synchronized是非公平锁？
非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。

### 问题六：什么是锁消除和锁粗化 ？
锁消除和锁粗化都是编译器级别对锁的优化。
锁消除：没有必要加锁的代码，但是确加了锁，在编译器编译的时候，会对加的锁删除，将锁消除。
锁粗化：锁粗化是跟锁消除的一个另一面：当需要加锁，但是锁加的粒度太细了。在编译器编译阶段，会将粒度太细没必要的锁，粗化成一个或多个大的锁。

### 问题七：为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？
不管是否会产生竞争，任何的数据操作都必须要先加锁、后操作。这样的策略就是悲观锁。synchronized的枷锁策略就是，在代码前后插入monitorenter、monitorexit。所以很明显，这是一个悲观锁。
乐观锁的核心算法是cas compare and swap。

### 问题八：乐观锁一定就是好的吗？

乐观锁，cas。存在三个问题：
1. ABA问题
2. 自旋开销过大
3. 只能针对单个变量进行cas


