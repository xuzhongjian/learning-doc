# 线程池源码分析 #

线程池的核心代码在 ThreadPoolExecutor 类。

## 几个参数 ##

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

corePoolSize：线程池的基本大小，用于执行的运行中的线程的池子。

maximumPoolSize：最大线程数量，线程池允许创建的最大线程数。
    如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。

keepAliveTime & unit：线程池的工作线程空闲后，保持存活的时间。
    如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。

workQueue：等待队列，在核心池线程运行中的线程达到指定的数量的时候，将后面提交的任务存储到这个队列中。

threadFactory：线程工厂，用来设置创建线程的策略。
    使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字。

handler：拒绝策略。
    AbortPolicy：直接抛出异常。
    CallerRunsPolicy：只用调用者所在线程来运行任务。
    DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
    DiscardPolicy：不处理，丢弃掉。

## 提交一个任务 ##

java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable)

```java
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
```

java.util.concurrent.AbstractExecutorService#newTaskFor(java.lang.Runnable, T)

```java
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
```

java.util.concurrent.ThreadPoolExecutor#execute

```java
    /**
     * 在未来的某个时刻执行给定的任务。
     * 这个任务可能在一个新线程也有可能在一个已经存在的线程里被执行。
     * 
     * 如果这个线程无法被提交、执行。或者是这个线程池已经被关闭，或者容量已经到了。
     * 那么这个任务就会按照当前的拒绝策略来处理。
     *
     * @param command 被执行任务。
     * @throws RejectedExecutionException 拒绝执行异常
     * @throws NullPointerException 如果给出的任务为空
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. 如果核心池的容量还没到（运行中的线程数量），尝试去开启一个新的线程。
         * 将这个任务作为这个新线程的第一个任务。
         *
         * 2. 如果这个任务能被成功的加入队列中，我们仍然需要双重校验一下，我们是否需要
         * 添加一个新的线程，如果之前的线程死了在上次检查之后，或者这个线程池关闭了。
         * 所以我们二次校验一下。我们新建一个线程或者回退这次的进入队列。
         *
         * 3. 如果无法加入到队列中，尝试去创建一个新的线程，如果失败了，就拒绝这个任务。
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 运行的线程数量已经饱和了 && 成功的向阻塞队列中添加了这个任务
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作
            // 这里需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
