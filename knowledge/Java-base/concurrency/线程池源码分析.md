# 线程池源码分析 #

线程池的核心代码在 ThreadPoolExecutor 类。

## 几个参数 ##

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

corePoolSize：线程池的基本大小，用于执行的运行中的线程的池子。

maximumPoolSize：最大线程数量，线程池允许创建的最大线程数。
    如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。

keepAliveTime & unit：线程池的工作线程空闲后，保持存活的时间。
    如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。

workQueue：等待队列，在核心池线程运行中的线程达到指定的数量的时候，将后面提交的任务存储到这个队列中。

threadFactory：线程工厂，用来设置创建线程的策略。
    使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字。

handler：拒绝策略。
    AbortPolicy：直接抛出异常。
    CallerRunsPolicy：只用调用者所在线程来运行任务。
    DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
    DiscardPolicy：不处理，丢弃掉。

## 提交一个任务 ##

java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable)

```java
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<Void> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
```

java.util.concurrent.AbstractExecutorService#newTaskFor(java.lang.Runnable, T)

```java
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
```

java.util.concurrent.ThreadPoolExecutor#execute

```java
    /**
     * 在未来的某个时刻执行给定的任务。
     * 这个任务可能在一个新线程也有可能在一个已经存在的线程里被执行。
     * 
     * 如果这个线程无法被提交、执行。或者是这个线程池已经被关闭，或者容量已经到了。
     * 那么这个任务就会按照当前的拒绝策略来处理。
     *
     * @param command 被执行任务。
     * @throws RejectedExecutionException 拒绝执行异常
     * @throws NullPointerException 如果给出的任务为空
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. 如果核心池的容量还没到（运行中的线程数量），尝试去开启一个新的线程。
         * 将这个任务作为这个新线程的第一个任务。
         *
         * 2. 如果这个任务能被成功的加入队列中，我们仍然需要双重校验一下，我们是否需要
         * 添加一个新的线程，如果之前的线程死了在上次检查之后，或者这个线程池关闭了。
         * 所以我们二次校验一下。我们新建一个线程或者回退这次的进入队列。
         *
         * 3. 如果无法加入到队列中，尝试去创建一个新的线程，如果失败了，就拒绝这个任务。
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 运行的线程数量已经饱和了 && 成功的向阻塞队列中添加了这个任务
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作
            // 这里需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

![线程池](../imgs/thread_pool.jpg)

java.util.concurrent.ThreadPoolExecutor#addWorker

```java

    /**
     * 根据当前的线程池的状态、核心或最大容量来判断一个新的工作线程能否被添加到
     * 当前的线程池。如果可以的话，相应的调整线程数量的计数值，如果可能，将创建
     * 并启动一个新的worker，并将firstTask作为其第一个任务运行。如果池已停止
     * 或有资格关闭，则此方法返回false。如果线程工厂在被请求时未能创建线程，它
     * 也会返回false。如果出现线程工厂返回null，或者因为异常，会快速回滚。
     *
     * @param 这个线程应该首先运行的任务。worker是用一个初始的第一个任务（在
     * execute方法中）创建的，当线程少于corePoolSize时（在这种情况下，我们总
     * 是启动一个线程），或者当队列已满时（在这种情况下，我们必须绕过队列）。最
     * 初空闲线程通常是通过prestartCoreThread创建的，或者用来替换其他正在消
     * 亡的工作线程。
     *
     * @param core如果为true，则使用corePoolSize，否则使用maximumPoolSize。
     * （这里使用的是布尔指示符，而不是值，以确保在检查其他池状态后读取新值）。
     * @return true if successful
     */
    private boolean addWorker(Runnable firstTask, boolean core) {
        //1. 自增workerCounter
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 异常情况的判断：线程池状态、任务、队列
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN && firstTask == null && ! workQueue.isEmpty()))
                return false;

            for (;;) {
                // workercount
                int wc = workerCountOf(c);
                //core true代表是往核心线程池中增加线程 false代表往最大线程池中增加线程
                if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                // cas的形式自增线程池的worker的数量
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();
                // 判断线程池的 worker 的数量是否发生的变化
                if (runStateOf(c) != rs)
                    continue retry; // 通常执行这个之后就返回false退出了
            }
        }
        
        //2. 新建线程，并加入到线程池workers中
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                // 对workers的锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // 获取runState
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // 获取锁之后，添加新的worker到线程池中
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    // 解锁
                    mainLock.unlock();
                }
                // 启动线程
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

调用t.start()之后，实质上调用的是Worker类的run()方法:
java.util.concurrent.ThreadPoolExecutor.Worker#run

```java
        /** 将主运行循环委托给外部runWorker。  */
        public void run() {
            runWorker(this);
        }
```

```java
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // 允许中断
        boolean completedAbruptly = true;
        try {
            // 此处循环获得任务，执行任务
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // 按照条件设置线程的中断状态
                if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &&  runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()){
                    wt.interrupt();
                }
                
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    // 完成的任务数量增加、解锁
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```

java.util.concurrent.ThreadPoolExecutor#getTask

```java
    private Runnable getTask() {
        boolean timedOut = false; // 上次的 poll 是否超时了

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // 仅在必要时检查队列是否为空。
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // workers 会被淘汰吗？
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            // wc过大，相对的wq过小，减少ctl的workerCount字段。
            if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c)){
                    return null;
                }
                continue;
            }

            try {
                // 取得任务，如果在 keepAliveTime 时间内还没有取得任务，那么在上面减少运行中的线程的时间。
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null){
                    return r;
                }
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```