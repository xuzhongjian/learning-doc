# 双重校验的单例模式 #

## 懒汉 - 线程不安全单例模式 ##

```java
package com.xuzhongjian.model;

import java.util.Objects;

/**
 * 懒汉 - 线程不安全 单例模式
 *
 * @author zjxu97 at 12/31/20 2:53 PM
 */
public class Instance {

    private static Instance instance;

    private Instance() {

    }

    public static Instance getInstance() {
        if (Objects.isNull(instance)) {
            instance = new Instance();
        }
        return instance;
    }
}
```

## 懒汉 - 线程安全单例模式 ##

上面是一个懒汉式线程不安全的单例模式，其中的静态方法 getInstance 可能会被多个方法同时调用。然后多个线程对 instance 这个静态变量的处理可能是一致的，也就是都认为其是一个空对象，没有被初始化。使用下面的方法，可以将其编程线程安全的单例模式：

```java
package com.xuzhongjian.model;

import java.util.Objects;

/**
 * 懒汉 - 线程安全 单例模式
 *
 * @author zjxu97 at 12/31/20 2:53 PM
 */
public class Instance {

    private static Instance instance;

    private Instance() {

    }

    public synchronized static Instance getInstance() {
        if (Objects.isNull(instance)) {
            instance = new Instance();
        }
        return instance;
    }
}
```

改动的地方只有一处，那就是在静态方法上加上了一个 synchronized 。加上这个变量的作用是，该方法只能同时允许一个地方调用，不允许多个位置调用。

但是在早期的JVM中，synchronized存在巨大的性能问题，所以提出了双重校验的办法：

## 双重校验 单例模式 ##

```java
package com.xuzhongjian.model;

import java.util.Objects;

/**
 * 双重校验 单例模式
 * 存在初始化风险
 *
 * @author zjxu97 at 12/31/20 2:53 PM
 */
public class Instance {

    private static Instance instance;

    private Instance() {

    }

    public static Instance getInstance() {
        if (Objects.isNull(instance)) {
            synchronized (Instance.class) {
                if (Objects.isNull(instance)) {
                    instance = new Instance();
                }
            }
        }
        return instance;
    }
}

```

这样的双重校验的方法可能存在的问题是，当上一个线程还没有将实例完全初始化，然后后一个线程读取到的对象还没有完全初始化。

如果使用 volatile，将instance实例变成 volatile 字段，可以解决这个问题：

```java
/**
 * 双重校验 单例模式
 * 终极版双重校验
 *
 * @author zjxu97 at 12/31/20 2:53 PM
 */
public class Instance {

    private volatile static Instance instance;

    private Instance() {

    }

    public static Instance getInstance() {
        if (Objects.isNull(instance)) {
            synchronized (Instance.class) {
                if (Objects.isNull(instance)) {
                    instance = new Instance();
                }
            }
        }
        return instance;
    }
}

```

这样就可以实现线程安全的返回延迟的实例化。

## 静态内部类 ##

使用静态内部类的方式实现单例模式：

```java
package com.xuzhongjian.model;

/**
 * 静态内部类实现单例模式
 *
 * @author zjxu97 at 12/31/20 2:53 PM
 */
public class Instance {

    private static class InnerInstance {
        private static Instance instance = new Instance();
    }

    private Instance() {

    }

    public static Instance getInstance() {
        return InnerInstance.instance;
    }
}
```

利用了类加载的时候 JVM 的Class初始化锁：

![类加载锁](../imgs/class_instance.jpg)

A线程首先拿到锁之后，对 instance 的 Class 对象进行初始化，待初始化完成之后，释放锁。再由 B 获取到锁之后，就不存在并发问题了，就能直接取到InnerInstance 的其中的静态变量。
